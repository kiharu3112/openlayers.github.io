"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6803],{34996:function(t,e,n){var o=n(49208),i=n(41564),s=n(43438),r=n(88887),l=n(98267),u=n(87240);function c(t,e,n,o){let i=o;const s=e+(n-e>>1);let r,l=n-e;const u=t[e],a=t[e+1],g=t[n],m=t[n+1];for(let o=e+3;o<n;o+=3){const e=f(t[o],t[o+1],u,a,g,m);if(e>i)r=o,i=e;else if(e===i){const t=Math.abs(o-s);t<l&&(r=o,l=t)}}i>o&&(r-e>3&&c(t,e,r,o),t[r+2]=i,n-r>3&&c(t,r,n,o))}function f(t,e,n,o,i,s){let r=i-n,l=s-o;if(0!==r||0!==l){const u=((t-n)*r+(e-o)*l)/(r*r+l*l);u>1?(n=i,o=s):u>0&&(n+=r*u,o+=l*u)}return r=t-n,l=e-o,r*r+l*l}function a(t,e,n,o){const i={id:null==t?null:t,type:e,geometry:n,tags:o,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};if("Point"===e||"MultiPoint"===e||"LineString"===e)g(i,n);else if("Polygon"===e)g(i,n[0]);else if("MultiLineString"===e)for(const t of n)g(i,t);else if("MultiPolygon"===e)for(const t of n)g(i,t[0]);return i}function g(t,e){for(let n=0;n<e.length;n+=3)t.minX=Math.min(t.minX,e[n]),t.minY=Math.min(t.minY,e[n+1]),t.maxX=Math.max(t.maxX,e[n]),t.maxY=Math.max(t.maxY,e[n+1])}function m(t,e,n,o){if(!e.geometry)return;const i=e.geometry.coordinates;if(i&&0===i.length)return;const s=e.geometry.type,r=Math.pow(n.tolerance/((1<<n.maxZoom)*n.extent),2);let l=[],u=e.id;if(n.promoteId?u=e.properties[n.promoteId]:n.generateId&&(u=o||0),"Point"===s)h(i,l);else if("MultiPoint"===s)for(const t of i)h(t,l);else if("LineString"===s)p(i,l,r,!1);else if("MultiLineString"===s){if(n.lineMetrics){for(const n of i)l=[],p(n,l,r,!1),t.push(a(u,"LineString",l,e.properties));return}d(i,l,r,!1)}else if("Polygon"===s)d(i,l,r,!0);else{if("MultiPolygon"!==s){if("GeometryCollection"===s){for(const i of e.geometry.geometries)m(t,{id:u,geometry:i,properties:e.properties},n,o);return}throw new Error("Input data is not a valid GeoJSON object.")}for(const t of i){const e=[];d(t,e,r,!0),l.push(e)}}t.push(a(u,s,l,e.properties))}function h(t,e){e.push(x(t[0]),y(t[1]),0)}function p(t,e,n,o){let i,s,r=0;for(let n=0;n<t.length;n++){const l=x(t[n][0]),u=y(t[n][1]);e.push(l,u,0),n>0&&(r+=o?(i*u-l*s)/2:Math.sqrt(Math.pow(l-i,2)+Math.pow(u-s,2))),i=l,s=u}const l=e.length-3;e[2]=1,c(e,0,l,n),e[l+2]=1,e.size=Math.abs(r),e.start=0,e.end=e.size}function d(t,e,n,o){for(let i=0;i<t.length;i++){const s=[];p(t[i],s,n,o),e.push(s)}}function x(t){return t/360+.5}function y(t){const e=Math.sin(t*Math.PI/180),n=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return n<0?0:n>1?1:n}function M(t,e,n,o,i,s,r,l){if(o/=e,s>=(n/=e)&&r<o)return t;if(r<n||s>=o)return null;const u=[];for(const e of t){const t=e.geometry;let s=e.type;const r=0===i?e.minX:e.minY,c=0===i?e.maxX:e.maxY;if(r>=n&&c<o){u.push(e);continue}if(c<n||r>=o)continue;let f=[];if("Point"===s||"MultiPoint"===s)P(t,f,n,o,i);else if("LineString"===s)S(t,f,n,o,i,!1,l.lineMetrics);else if("MultiLineString"===s)L(t,f,n,o,i,!1);else if("Polygon"===s)L(t,f,n,o,i,!0);else if("MultiPolygon"===s)for(const e of t){const t=[];L(e,t,n,o,i,!0),t.length&&f.push(t)}if(f.length){if(l.lineMetrics&&"LineString"===s){for(const t of f)u.push(a(e.id,s,t,e.tags));continue}"LineString"!==s&&"MultiLineString"!==s||(1===f.length?(s="LineString",f=f[0]):s="MultiLineString"),"Point"!==s&&"MultiPoint"!==s||(s=3===f.length?"Point":"MultiPoint"),u.push(a(e.id,s,f,e.tags))}}return u.length?u:null}function P(t,e,n,o,i){for(let s=0;s<t.length;s+=3){const r=t[s+i];r>=n&&r<=o&&Y(e,t[s],t[s+1],t[s+2])}}function S(t,e,n,o,i,s,r){let l=w(t);const u=0===i?X:b;let c,f,a=t.start;for(let g=0;g<t.length-3;g+=3){const m=t[g],h=t[g+1],p=t[g+2],d=t[g+3],x=t[g+4],y=0===i?m:h,M=0===i?d:x;let P=!1;r&&(c=Math.sqrt(Math.pow(m-d,2)+Math.pow(h-x,2))),y<n?M>n&&(f=u(l,m,h,d,x,n),r&&(l.start=a+c*f)):y>o?M<o&&(f=u(l,m,h,d,x,o),r&&(l.start=a+c*f)):Y(l,m,h,p),M<n&&y>=n&&(f=u(l,m,h,d,x,n),P=!0),M>o&&y<=o&&(f=u(l,m,h,d,x,o),P=!0),!s&&P&&(r&&(l.end=a+c*f),e.push(l),l=w(t)),r&&(a+=c)}let g=t.length-3;const m=t[g],h=t[g+1],p=t[g+2],d=0===i?m:h;d>=n&&d<=o&&Y(l,m,h,p),g=l.length-3,s&&g>=3&&(l[g]!==l[0]||l[g+1]!==l[1])&&Y(l,l[0],l[1],l[2]),l.length&&e.push(l)}function w(t){const e=[];return e.size=t.size,e.start=t.start,e.end=t.end,e}function L(t,e,n,o,i,s){for(const r of t)S(r,e,n,o,i,s,!1)}function Y(t,e,n,o){t.push(e,n,o)}function X(t,e,n,o,i,s){const r=(s-e)/(o-e);return Y(t,s,n+(i-n)*r,1),r}function b(t,e,n,o,i,s){const r=(s-n)/(i-n);return Y(t,e+(o-e)*r,s,1),r}function z(t,e){const n=[];for(let o=0;o<t.length;o++){const i=t[o],s=i.type;let r;if("Point"===s||"MultiPoint"===s||"LineString"===s)r=I(i.geometry,e);else if("MultiLineString"===s||"Polygon"===s){r=[];for(const t of i.geometry)r.push(I(t,e))}else if("MultiPolygon"===s){r=[];for(const t of i.geometry){const n=[];for(const o of t)n.push(I(o,e));r.push(n)}}n.push(a(i.id,s,r,i.tags))}return n}function I(t,e){const n=[];n.size=t.size,void 0!==t.start&&(n.start=t.start,n.end=t.end);for(let o=0;o<t.length;o+=3)n.push(t[o]+e,t[o+1],t[o+2]);return n}function E(t,e){if(t.transformed)return t;const n=1<<t.z,o=t.x,i=t.y;for(const s of t.features){const t=s.geometry,r=s.type;if(s.geometry=[],1===r)for(let r=0;r<t.length;r+=2)s.geometry.push(F(t[r],t[r+1],e,n,o,i));else for(let r=0;r<t.length;r++){const l=[];for(let s=0;s<t[r].length;s+=2)l.push(F(t[r][s],t[r][s+1],e,n,o,i));s.geometry.push(l)}}return t.transformed=!0,t}function F(t,e,n,o,i,s){return[Math.round(n*(t*o-i)),Math.round(n*(e*o-s))]}function Z(t,e,n,o,i){const s=e===i.maxZoom?0:i.tolerance/((1<<e)*i.extent),r={features:[],numPoints:0,numSimplified:0,numFeatures:t.length,source:null,x:n,y:o,z:e,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const e of t)C(r,e,s,i);return r}function C(t,e,n,o){const i=e.geometry,s=e.type,r=[];if(t.minX=Math.min(t.minX,e.minX),t.minY=Math.min(t.minY,e.minY),t.maxX=Math.max(t.maxX,e.maxX),t.maxY=Math.max(t.maxY,e.maxY),"Point"===s||"MultiPoint"===s)for(let e=0;e<i.length;e+=3)r.push(i[e],i[e+1]),t.numPoints++,t.numSimplified++;else if("LineString"===s)O(r,i,t,n,!1,!1);else if("MultiLineString"===s||"Polygon"===s)for(let e=0;e<i.length;e++)O(r,i[e],t,n,"Polygon"===s,0===e);else if("MultiPolygon"===s)for(let e=0;e<i.length;e++){const o=i[e];for(let e=0;e<o.length;e++)O(r,o[e],t,n,!0,0===e)}if(r.length){let n=e.tags||null;if("LineString"===s&&o.lineMetrics){n={};for(const t in e.tags)n[t]=e.tags[t];n.mapbox_clip_start=i.start/i.size,n.mapbox_clip_end=i.end/i.size}const l={geometry:r,type:"Polygon"===s||"MultiPolygon"===s?3:"LineString"===s||"MultiLineString"===s?2:1,tags:n};null!==e.id&&(l.id=e.id),t.features.push(l)}}function O(t,e,n,o,i,s){const r=o*o;if(o>0&&e.size<(i?r:o))return void(n.numPoints+=e.length/3);const l=[];for(let t=0;t<e.length;t+=3)(0===o||e[t+2]>r)&&(n.numSimplified++,l.push(e[t],e[t+1])),n.numPoints++;i&&function(t,e){let n=0;for(let e=0,o=t.length,i=o-2;e<o;i=e,e+=2)n+=(t[e]-t[i])*(t[e+1]+t[i+1]);if(n>0===e)for(let e=0,n=t.length;e<n/2;e+=2){const o=t[e],i=t[e+1];t[e]=t[n-2-e],t[e+1]=t[n-1-e],t[n-2-e]=o,t[n-1-e]=i}}(l,s),t.push(l)}const T={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};class j{constructor(t,e){const n=(e=this.options=function(t,e){for(const n in e)t[n]=e[n];return t}(Object.create(T),e)).debug;if(n&&console.time("preprocess data"),e.maxZoom<0||e.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(e.promoteId&&e.generateId)throw new Error("promoteId and generateId cannot be used together.");let o=function(t,e){const n=[];if("FeatureCollection"===t.type)for(let o=0;o<t.features.length;o++)m(n,t.features[o],e,o);else"Feature"===t.type?m(n,t,e):m(n,{geometry:t},e);return n}(t,e);this.tiles={},this.tileCoords=[],n&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",e.indexMaxZoom,e.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),o=function(t,e){const n=e.buffer/e.extent;let o=t;const i=M(t,1,-1-n,n,0,-1,2,e),s=M(t,1,1-n,2+n,0,-1,2,e);return(i||s)&&(o=M(t,1,-n,1+n,0,-1,2,e)||[],i&&(o=z(i,1).concat(o)),s&&(o=o.concat(z(s,-1)))),o}(o,e),o.length&&this.splitTile(o,0,0,0),n&&(o.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(t,e,n,o,i,s,r){const l=[t,e,n,o],u=this.options,c=u.debug;for(;l.length;){o=l.pop(),n=l.pop(),e=l.pop(),t=l.pop();const f=1<<e,a=v(e,n,o);let g=this.tiles[a];if(!g&&(c>1&&console.time("creation"),g=this.tiles[a]=Z(t,e,n,o,u),this.tileCoords.push({z:e,x:n,y:o}),c)){c>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",e,n,o,g.numFeatures,g.numPoints,g.numSimplified),console.timeEnd("creation"));const t=`z${e}`;this.stats[t]=(this.stats[t]||0)+1,this.total++}if(g.source=t,null==i){if(e===u.indexMaxZoom||g.numPoints<=u.indexMaxPoints)continue}else{if(e===u.maxZoom||e===i)continue;if(null!=i){const t=i-e;if(n!==s>>t||o!==r>>t)continue}}if(g.source=null,0===t.length)continue;c>1&&console.time("clipping");const m=.5*u.buffer/u.extent,h=.5-m,p=.5+m,d=1+m;let x=null,y=null,P=null,S=null,w=M(t,f,n-m,n+p,0,g.minX,g.maxX,u),L=M(t,f,n+h,n+d,0,g.minX,g.maxX,u);t=null,w&&(x=M(w,f,o-m,o+p,1,g.minY,g.maxY,u),y=M(w,f,o+h,o+d,1,g.minY,g.maxY,u),w=null),L&&(P=M(L,f,o-m,o+p,1,g.minY,g.maxY,u),S=M(L,f,o+h,o+d,1,g.minY,g.maxY,u),L=null),c>1&&console.timeEnd("clipping"),l.push(x||[],e+1,2*n,2*o),l.push(y||[],e+1,2*n,2*o+1),l.push(P||[],e+1,2*n+1,2*o),l.push(S||[],e+1,2*n+1,2*o+1)}}getTile(t,e,n){t=+t,e=+e,n=+n;const o=this.options,{extent:i,debug:s}=o;if(t<0||t>24)return null;const r=1<<t,l=v(t,e=e+r&r-1,n);if(this.tiles[l])return E(this.tiles[l],i);s>1&&console.log("drilling down to z%d-%d-%d",t,e,n);let u,c=t,f=e,a=n;for(;!u&&c>0;)c--,f>>=1,a>>=1,u=this.tiles[v(c,f,a)];return u&&u.source?(s>1&&(console.log("found parent tile z%d-%d-%d",c,f,a),console.time("drilling down")),this.splitTile(u.source,c,f,a,t,e,n),s>1&&console.timeEnd("drilling down"),this.tiles[l]?E(this.tiles[l],i):null):null}}function v(t,e,n){return 32*((1<<t)*n+e)+t}const A=function(t,e){if(!e||!e.geometry)return e;let n;const o=e.type;let i=e.geometry;return 1===o?(n="MultiPoint",1==i.length&&(n="Point",i=i[0])):2===o?(n="MultiLineString",1==i.length&&(n="LineString",i=i[0])):3===o&&(n="Polygon",i.length>1&&(n="MultiPolygon",i=[i])),{type:"Feature",geometry:{type:n,coordinates:i},properties:e.tags}},k=new r.A({background:"#1a2b39",style:{"fill-color":["string",["get","COLOR"],"#eee"]}}),J=new i.A({layers:[k],target:"map",view:new u.Ay({center:[0,0],zoom:2})});fetch("https://openlayers.org/data/vector/ecoregions.json").then((function(t){return t.json()})).then((function(t){const e=new j(t,{extent:4096,debug:1});const n=new o.A({dataProjection:new s.A({code:"TILE_PIXELS",units:"tile-pixels",extent:[0,0,4096,4096]})}),i=new l.A({tileUrlFunction:function(t){return JSON.stringify(t)},tileLoadFunction:function(t,o){const s=JSON.parse(o),r=e.getTile(s[0],s[1],s[2]),l=JSON.stringify({type:"FeatureCollection",features:r?r.features:[]},A),u=n.readFeatures(l,{extent:i.getTileGrid().getTileCoordExtent(s),featureProjection:J.getView().getProjection()});t.setFeatures(u)}});k.setSource(i)}))}},function(t){var e;e=34996,t(t.s=e)}]);
//# sourceMappingURL=geojson-vt.js.map